import matplotlib.pyplot as plt
import numpy as np
import math

"""
This program is used to transform the emission data from MATsim into valid inputs for ARIA. It also allows to visualise the emissions.
It is divided like this :
    - config
    - preliminary functions
    - emissions to dict
    - emission map
    - emission to CSV
    - map to CSV
    - preliminary functions
    - surfacic emissions
    - run
"""

## CONFIG

#inputs
file = "Documents/X/2A/PSC/exemples de formats/[500pax]10.events.xml" #this is the event file generated by MATsim
mapfile = "Documents/X/2A/PSC/exemples de formats/network_rouen_moyen.xml" #this is the network file
pollutant = "PM" #the pollutant studied

#outputs
emissions_file = "Documents/X/2A/PSC/exemples de formats/emissions.csv" #gives the emission for each hour for each link in the ARIA format
map_csv_file = "Documents/X/2A/PSC/exemples de formats/map.csv" #gets the network in ARIA format
output_file = "Documents/X/2A/PSC/exemples de formats/surfacic_emissions.csv" #gives the emission for each hour for each rectangle in the ARIA format
surface_network = "Documents/X/2A/PSC/exemples de formats/surface_network.csv" #a division of the zone in rectangles compatible with ARIA

date = "01/01/2018 " #written in the emissions csv file. Needs to correspond to the date used for the ARIA simulation.

resolution = 100 #number of divisions for the surfacic division

## PRELEMINARY FUNCTIONS

def file_len(fname):
    """This function returns the number of lines in the file"""
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1

def xmlline_to_dict(s):
    """This function changes a xml line to a dict"""
    s = s.replace('=', "':")
    s = s.replace('"', "'")
    s = s.replace('<event ', "{'")
    s = s.replace('  />', "}")
    s = s.replace("vehicle enters traffic", "vehicle_enters_traffic")
    s = s.replace("vehicle leaves traffic", "vehicle_leaves_traffic")
    s = s.replace("left link", "left_link")
    s = s.replace("entered link", "entred_link")
        
    for i in range(len(s)) :
        if s[i] in "azertyuiopmlkjhgfdsqwxcvbnAZERTYUIOPMLKJHGFDSQWXCVBN":
            if s[i-1] == " ":
                s = s[:i] + "'" + s[i:]
        if s[i]=="'" :
            if s[i+1] == " ":
                s = s[:i+1] + "," + s[i+1:]
    
    for i in range(len(s)) :
        if s[i] in "azertyuiopmlkjhgfdsqwxcvbnAZERTYUIOPMLKJHGFDSQWXCVBN":
            if s[i-1] == " ":
                s = s[:i] + "'" + s[i:]
        if s[i]=="'" :
            if s[i+1] == " ":
                s = s[:i+1] + "," + s[i+1:]
    
    s = s.replace(':', " : ")
        
    s_dict = eval(s)
    
    return s_dict


def time_format(secondes):
    """this function takes a time entry as a float number of seconds and returns a string "hh:mm:ss" """
    
    secondes = round(secondes)
    time = ""
    hours = secondes//3600
    if (hours > 9) :
        time += str(hours) + ":"
    else :
        time += "0" + str(hours) + ":"
    secondes %= 3600
    
    minutes = secondes//60
    if (minutes > 9) :
        time += str(minutes) + ":"
    else:
        time += "0" + str(minutes) + ":"

    secondes %= 60
    if (secondes > 9) :
        time += str(secondes)
    else:
        time += "0"+str(secondes)
    return time

def num(s):
    try:
        return int(s)
    except ValueError:
        return float(s)

###EMISSIONS TO DICT


def emissions_to_dict(pollutant):
    """extracts polluant corresponding to the string "pollutant" in a dict"""
    source = open(file, "r")
    
    #Skip the first two lines
    source.readline()
    source.readline()
    
    events=list()
    
    #Reads all lines, except for the last one
    for i in range(file_len(file)-3):
        ligne = source.readline()
        events.append(xmlline_to_dict(ligne))
        
    emissions=dict()
    
    #On ajoute les heures au dictionnaire
    for i in range(24):
        emissions[str(i)]=dict()
        
    for event in events :
        event_type = event["type"]
        if event_type=="coldEmissionEvent" or event_type=="warmEmissionEvent" :
            link = event["linkId"]
            PM = float(event["PM"])
            time = int(float(event["time"]))//3600
            if link in emissions[str(time)]:
                emissions[str(time)][link]+=PM
            else :
                emissions[str(time)][link]=PM
    
    return emissions

def agregate_data(emissions):
    """ returns a dictionnary containing, for each hour, the emissions aggregated spatially"""
    agregate = dict()
    for hour in emissions:
        tot_em=0
        for link in emissions[hour] :
            tot_em+=emissions[hour][link]
        agregate[hour]=tot_em
    return agregate

def trace_agregate_data(emissions):
    """ plots the spatially-aggregated emissions data over time"""
    agreg_data=agregate_data(emissions)
    X=[i for i in range(24)]
    Y=[agreg_data[str(i)] for i in range(24)]
    plt.plot(X,Y)
    plt.show()
    return


###EMISSION MAP

def map_to_dict():
    """ this function transforms the xml network used by MATSim into :
    - a dictionnary link_dict, whose keys are the links id (as strings), whose value is the list x1,y1,x2,y2 (as strings)
    - a list roads, each line of the form [link id as string, [x1,x2 as int], [y1,y2 as int]]
     """
    
    source = open(mapfile, "r")
    
    #We get the content of the file
    s = source.readlines()
    
    #We make one big string
    s2 = str()
    for i in s : 
        s2=s2+i
    s=s2
    
    #We get rid of the first part of the string, and get the links and nodes
    s=s.split('<nodes>')[1]
    nodes, links = s.split('</nodes>')
    links = links.split('</links>')[0]
    links = links.split('<links')[1]
    
    #We make dicts of all nodes and links
    
    #First the nodes
    nodes = nodes.split("<node")
    #We get rid of anomalies
    nodes2 = list()
    for node in nodes:
        if ("id" in node):
            nodes2.append(node.split("/>")[0])
    nodes = nodes2
    node_dict = dict()
    #We make a dictionnary
    for node in nodes:
        l1 = node.split('="')
        l2 = list()
        for i in l1:
            l2=l2+i.split('"')
        node_dict[int(l2[1])]=[l2[3],l2[5]]
    
    #Then the links
    links = links.split("<link")
    #We get rid of anomalies
    links2 = list()
    for link in links:
        if ("id=" in link):
            links2.append(link.split("/>")[0])
    links = links2
    link_dict = dict()
    #We make a dictionnary
    for link in links:
        l1 = link.split('="')
        l2 = list()
        for i in l1:
            l2=l2+i.split('"')
        link_dict[l2[1]]=[l2[3],l2[5]]
        
    #Then, we mix the two to get the map
    for link in link_dict:
        link_dict[link] = node_dict[int(link_dict[link][0])] + node_dict[int(link_dict[link][1])]
    
    #We generate the map
    
    #x_nodes = [num(node_dict[key][0]) for key in node_dict]
    #y_nodes = [num(node_dict[key][1]) for key in node_dict]
    
    roads = list()
    for link in link_dict:
        roads.append([link, [num(link_dict[link][0]),num(link_dict[link][2])],[num(link_dict[link][1]),num(link_dict[link][3])]])
    
    return roads, link_dict

#Hour by hour 

def colorcode(hour, link):
    """ this function takes as arguments the hour (e.g. '23') and the link (as a list containing the link id in the first position) and returns the color (coded by a char) of the link (green, yellow or red respectively for low, medium and high emissions). """
    
    #parameters
    limit_low_medium = 0.01
    limit_medium_high = 0.1
    
    if link[0] in emissions[hour].keys():
        emission = emissions[hour][link[0]]
        if emission<limit_low_medium : 
            return 'g'
        if emission<limit_medium_high :
            return 'y'
        else :
            return 'r'
    #if link[0] is not in the keys of emissions[hour], it means there are no emissions, so color is green
    return 'g'

def image_output(roads):
    """saves the 24 images, showing the network emissions for each hour. """
    for link in roads:
        plt.plot(link[1], link[2], color='k')
    
    for hour in range(24):
        
        #Size and font
        #Size
        plt.figure(figsize=(10,10))
        #Font
        ax = plt.subplot(111,title="Situation at hour "+str(hour))
        for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] +
            ax.get_xticklabels() + ax.get_yticklabels()):
                item.set_fontsize(20)
        for link in roads:
            plt.plot(link[1], link[2], color=colorcode(str(hour), link), linewidth=5)
        plt.savefig('images/hour'+str(hour)+'.png')
        #plt.show()
    return


###EMISSIONS TO CSV

def emissions_to_csv():
    """ this function creates (or overwrites) the emissions csv file, in a format that is directly usable as ARIA's lineic chronologic emission file"""
    csv = open(emissions_file, "w")
    csv.write("SRCEID;DATEDEB;DATEFIN;Q_PM10\n")
    for hour in range(24):
        if str(hour) in emissions.keys():
            for link in emissions[str(hour)]:
                linkid = num(link)
                datedeb = date + time_format(hour*3600)
                datefin = date + time_format((hour+1)*3600)
                em = round(emissions[str(hour)][link],5)
                csv.write(str(linkid)+';'+datedeb+';'+datefin+';'+str(em)+"\n")
    
    csv.close()
    return

###MAP TO CSV

def map_to_csv():
    """this function creates (or overwrites) the map csv file, which contains the column id, x1, y1, x2, y2, all of type int"""
    csv = open(map_csv_file, "w")
    
    csv.write("id1;x1;y1;x2;y2\n")
    for link in link_dict:
        linkid = link
        x1=link_dict[link][0]
        y1=link_dict[link][1]
        x2=link_dict[link][2]
        y2=link_dict[link][3]
        csv.write(str(linkid)+';'+x1+';'+y1+';'+x2+';'+y2+"\n")
    
    csv.close()
    return



### PRELLIMINARY FUNCTIONS


def get_bounderies():
    """returns x_min,x_max,y_min,y_max, using link_dict. Does not work if coordinates are bigger than 10**9."""
    x_min=10000000000
    x_max=-10000000000
    y_min=10000000000
    y_max=-10000000000
    for link in link_dict:
        if float(link_dict[link][0])<x_min:
            x_min=float(link_dict[link][0])
        if float(link_dict[link][0])>x_max:
            x_max=float(link_dict[link][0])
            
        if float(link_dict[link][2])<x_min:
            x_min=float(link_dict[link][2])
        if float(link_dict[link][2])>x_max:
            x_max=float(link_dict[link][2])

        if float(link_dict[link][1])<y_min:
            y_min=float(link_dict[link][1])
        if float(link_dict[link][1])>y_max:
            y_max=float(link_dict[link][1])
        
        if float(link_dict[link][3])<y_min:
            y_min=float(link_dict[link][3])
        if float(link_dict[link][3])>y_max:
            y_max=float(link_dict[link][3])
    
    return x_min,x_max,y_min,y_max
       

def f(x1,y1,x2,y2,x):
    """Calculates the image of a scalar by a linear function"""
    if x1==x2:
        return x1
    a=(y2-y1)/(x2-x1)
    return(a*(x-x1)+y1)
        
    
def surroundings(X,Y,x1,x2,y1,y2):
    """Returns the coordinates which surround x1,x2,y1,y2 in X and Y"""
    idown,iup = 0,0
    jdown,jup= 0,0
    ymin,ymax=min(y1,y2),max(y1,y2)
    
    while X[idown+1]<x1 and idown < resolution-2:
        idown+=1

    while x2 >= X[iup] and iup < resolution-2:
        iup+=1            

    while Y[jdown+1] < ymin and jdown < resolution-2:
        jdown+=1

    while ymax >= Y[jup] and jup < resolution-2:
        jup+=1

    return(idown,iup,jdown,jup)


### SURFACIC EMISSIONS
    
def create_surfacic_emissions(hour):
    """Returns a matrix with the surfacic emissions in each square. Time here is fixed."""

    #Cutting the city into small squares
    X = np.linspace(x_min,x_max,resolution)
    Y = np.linspace(y_min,y_max,resolution)
        
    
    #Density matrix
    surfacic_emissions=np.zeros((resolution-1,resolution-1))

    
    for link in link_dict:
        
        visited =[]
        
        #Coordinates of the beginning and the end of the link
        x1,x2=float(link_dict[link][0]),float(link_dict[link][2])
        y1,y2=float(link_dict[link][1]),float(link_dict[link][3])        
        
        #Surroundigs
        idown,iup,jdown,jup=surroundings(X,Y,x1,x2,y1,y2)
        
        #if there are emissions :
        if link in emissions[hour]:
            for i in range(idown+1,iup):
                x=X[i]
                                
                #Ordinate of the intersection point between the link and the verticle line (equation x=...)                        
                ord=f(x1,y1,x2,y2,x)
    
                for j in range(jdown,jup) :
                        
                    if ord >= Y[j] and ord<=Y[j+1]:
                        
                        if (resolution-2-j,i) not in visited:
                            visited.append([resolution-2-j,i])
                            
                        if (resolution-2-j,i-1) not in visited:
                            visited.append([resolution-2-j,i-1])
            
            for j in range(jdown+1,jup):
                y=Y[j]
                
                #Abscissa of the intersection point between the link and the horizontal line (equation y=...)
                absc=f(y1,x1,y2,x2,y)
                
                for i in range(idown,iup):
                    
                    if absc >= X[i] and absc <= X[i+1]:
    
                        if (resolution-2-j,i) not in visited:
                            visited.append([resolution-2-j,i])
    
                        if (resolution-2-j+1,i) not in visited:
                            visited.append([resolution-2-j,i])
                            
            c = len(visited) #number of squares crossed
            
            for couple in visited:
                surfacic_emissions[couple[0],couple[1]]+= emissions[hour][link] /c
    
    return surfacic_emissions

def create_csv():
    """This creates the CSV file used in ARIA to give for each hour and for each surface the amount of pollutant emitted. """
    f = open(output_file, "w")
    
    f.write("SRCEID;DATEDEB;DATEFIN;Q_PM10\n")
    
    for hour in range(24):
        surfacic_emissions = create_surfacic_emissions(str(hour))
        
        for i in range(len(surfacic_emissions)):
            for j in range(len(surfacic_emissions[0])):
                if surfacic_emissions[i][j]>0:
                    f.write(str(i+1000*j)+";"+date+time_format(hour*3600)+";"+date+time_format((hour+1)*3600)+";"+str(surfacic_emissions[i][j])+"\n")
    f.close()
    return

def create_surface_network():
    """this creates the file used in ARIA to define where are the surfacic emissions taking place : it links IDs to coordinates. The only parameters here are x_min,x_may,y_min,y_max, and the resolution ; it does not depend on the emissions."""
    new = []
    new.append("SRCEID;IDADM1;IDADM2;NAMADM;NAMGP1;NAMGP2;NAMGP3;IDCLA1;IDCLA2;IDCLA3;IDCLA4;IDCLA5;IDPROJ;SHIFTX;ORIGX;ORIGY;IDZH;X1;Y1;X2;Y2;X3;Y3;X4;Y4;DZ;ENVOL;SPEEDX;SPEEDY;SPEEDZ;IDUNIT_PM10;Q_PM10")
    
    for i in range(resolution):
        for j in range(resolution):
            x_left = x_min + i*amplitude_x/resolution
            y_up = y_max - j*amplitude_y/resolution
            
            line = str(i+1000*j)
            line += ";-999;-999;NULL;STEP;NULL;"
            line += str(i+1000*j)
            line += ";-999;-999;-999;-999;-999;31;0;0;0;1;"
            line += str(x_left)+";"+str(y_up-amplitude_y/resolution)+";"
            line += str(x_left+amplitude_x/resolution)+";"+str(y_up-amplitude_y/resolution)+";"
            line += str(x_left+amplitude_x/resolution)+";"+str(y_up)+";"
            line += str(x_left)+";"+str(y_up)+";"            
            line += "0;0;0;0;0;3;1" #the 3 corresponds to units, here in kg/hour
            
            new.append(line)
    
    f= open(surface_network,"w")
    for line in new:
        f.write(line+'\n')
    f.close()


def graph(hour, interpolation = True):
    """Draws the emissions generated at a given hour. By default, data is interpolated. """
    surfacic_emissions=create_surfacic_emissions(hour)
    l=len(surfacic_emissions[0])
    
    
    Z=list()
    for i in range(l):
        Z.insert(0,[])
        for j in range(l):
            Z[0].append(surfacic_emissions[resolution-2-i][j])
    
    f, ax = plt.subplots()
    ax.set_title('emissions')
    if interpolation:
        ax.imshow(Z,interpolation='bilinear',extent = (x_min,x_max,y_min,y_max))
    else:
        ax.imshow(Z,interpolation='none',extent = (x_min,x_max,y_min,y_max))
        
    plt.show()
    return

### RUN

#formatting data to simplify the following
emissions = emissions_to_dict(pollutant)
roads, link_dict = map_to_dict()

x_min,x_max,y_min,y_max=get_bounderies()
amplitude_x = x_max-x_min
amplitude_y = y_max-y_min 

#visualization of results
#trace_agregate_data(emissions)
#image_output(roads)
#graph("8")

#writing output files
emissions_to_csv()
map_to_csv()
create_csv()
create_surface_network()
